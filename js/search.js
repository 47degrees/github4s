// When the user clicks on the search box, we want to toggle the search dropdown
function displayToggleSearch(e) {
  e.preventDefault();
  e.stopPropagation();

  closeDropdownSearch(e);
  
  if (idx === null) {
    console.log("Building search index...");
    prepareIdxAndDocMap();
    console.log("Search index built.");
  }
  const dropdown = document.querySelector("#search-dropdown-content");
  if (dropdown) {
    if (!dropdown.classList.contains("show")) {
      dropdown.classList.add("show");
    }
    document.addEventListener("click", closeDropdownSearch);
    document.addEventListener("keydown", searchOnKeyDown);
    document.addEventListener("keyup", searchOnKeyUp);
  }
}

//We want to prepare the index only after clicking the search bar
var idx = null
const docMap = new Map()

function prepareIdxAndDocMap() {
  const docs = [  
    {
      "title": "Activity API",
      "url": "/github4s/activity",
      "content": "Activity API Github4s supports the Activity API. As a result, with Github4s, you can interact with: Notifications Set a thread subscription Starring List stargazers List starred repositories List public organization events List public repository events The following examples assume the following code: import cats.effect.IO import github4s.Github import org.http4s.client.{Client, JavaNetClientBuilder} val httpClient: Client[IO] = JavaNetClientBuilder[IO].create // You can use any http4s backend val accessToken = sys.env.get(\"GITHUB_TOKEN\") val gh = Github[IO](httpClient, accessToken) Notifications Set a Thread Subscription This lets you subscribe or unsubscribe from a conversation. Unsubscribing from a conversation mutes all future notifications (until you comment or get @mentioned once more). You can subscribe or unsubscribe using setThreadSub; it takes as arguments: id: Thread id from which you subscribe or unsubscribe. subscribed: Determines if notifications should be received from this thread. ignored: Determines if all notifications should be blocked from this thread. val threadSub = gh.activities.setThreadSub(5, true, false) threadSub.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the created or deleted Subscription. See the API doc for full reference. Starring List stargazers You can list the users starring a specific repository with listStargazers; it takes as arguments: the repository coordinates (owner and name of the repository). timeline: whether or not to return the date at which point the user starred the repository. pagination: Limit and Offset for pagination, optional. To list the stargazers of 47degrees/github4s: val listStargazers = gh.activities.listStargazers(\"47degrees\", \"github4s\", true) listStargazers.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[Stargazer]. See the API doc for full reference. List starred repositories You can list the repositories starred by a particular user with listStarredRepositories; it takes as arguments: username: name of the user for which we want to retrieve the starred repositories. timeline: whether or not to return the date at which point the user starred the repository. sort: how to sort the result, can be ‚Äúcreated‚Äù (when the repo was starred) or ‚Äúupdated‚Äù (when the repo was last pushed to), optional. direction: ‚Äúasc‚Äù or ‚Äúdesc‚Äù, optional. pagination: Limit and Offset for pagination, optional. To list the starred repositories for user rafaparadela: val listStarredRepositories = gh.activities.listStarredRepositories(\"rafaparadela\", true) listStarredRepositories.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[StarredRepository]. See the API doc for full reference. List public organization events You can list the events of a particular public organization with listPublicOrganizationEvents; it takes as arguments: org: name of the organization for which we want to retrieve the events. pagination: Limit and Offset for pagination, optional. To list the events for org 47degrees: val listPublicOrganizationEvents = gh.activities.listPublicOrganizationEvents(\"47degrees\") listPublicOrganizationEvents.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[PublicGitHubEvent]. See the API doc for full reference. List public repository events You can list the events of a particular repository with listPublicRepositoryEvents; it takes as arguments: owner: The account owner of the repository. The name is not case sensitive. repo: The name of the repository. The name is not case sensitive. pagination: Limit and Offset for pagination, optional. To list the events from the github4s repository owned by 47degrees: val listPublicRepositoryEvents = gh.activities.listPublicRepositoryEvents(\"47degrees\", \"github4s\") listPublicRepositoryEvents.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[PublicGitHubEvent]. See the API doc for full reference. As you can see, a few features of the activity endpoint are missing. As a result, if you‚Äôd like to see a feature supported, feel free to create an issue and/or a pull request!"
    } ,    
    {
      "title": "Authorization API",
      "url": "/github4s/auth",
      "content": "Authorization API Github4s supports the Authorization API. As a result, with Github4s, you can: Authorize a url Get an access token Previously, you were able to use the authorizations API with a username and password. This has been removed from the GitHub API as of November 13, 2020, and has also been removed from Github4s. For more information, see this documentation notice. The following examples assume the following code: import cats.effect.IO import github4s.Github import org.http4s.client.{Client, JavaNetClientBuilder} val httpClient: Client[IO] = JavaNetClientBuilder[IO].create // You can use any http4s backend val gh = Github[IO](httpClient, None) NOTE: Above you can see Github(httpClient, None). This is due to the fact that if you are authenticating for the first time you don‚Äôt have any access token yet. Authorize a url Generates an authorize url with a random state, both are returned within an Authorize. You can authorize a url using authorizeUrl; it takes as arguments: client_id: the 20 character OAuth app client key for which to create the token. redirect_uri: the URL in your app where users will be sent to after authorization. scopes: attached to the token, for more information see the scopes doc. val authorizeUrl = gh.auth.authorizeUrl( \"e8e39175648c9db8c280\", \"http://localhost:9000/_oauth-callback\", List(\"public_repo\")) authorizeUrl.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the created Authorize. See the API doc for full reference. Get an access token Requests an access token based on the code retrieved in the Create a new authorization token step of the OAuth process. You can get an access token using getAccessToken; it takes as arguments: client_id: the 20 character OAuth app client key for which to create the token. client_secret: the 40 character OAuth app client secret for which to create the token. code: the code you received as a response to Create a new authorization token. redirect_uri: the URL in your app where users will be sent after authorization. state: the unguessable random string you optionally provided in Create a new authorization token. val getAccessToken = gh.auth.getAccessToken( \"e8e39175648c9db8c280\", \"1234567890\", \"code\", \"http://localhost:9000/_oauth-callback\", \"status\") getAccessToken.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding OAuthToken. See the API doc for full reference. As you can see, a few features of the authorization endpoint are missing. As a result, if you‚Äôd like to see a feature supported, feel free to create an issue and/or a pull request!"
    } ,    
    {
      "title": "Changelog",
      "url": "/github4s/changelog",
      "content": "Changelog v0.28.1 (2021-01-28) Full Changelog v0.28.0 (2021-01-27) Full Changelog üêõ Bug Fixes Fix #569 - Manually encode Uri query parameters #596 (sloshy) Unbreak the build (fix #586 #597) #595 (sloshy) üìà Dependency updates Update Scala: 2.12.12/2.13.4, sbt-mdoc: 2.2.16 #601 (sloshy) Update http4s-blaze-client, http4s-circe, ‚Ä¶ to 0.21.16 #600 (47erbot) Update base64 to 0.3.0 #598 (47erbot) Update http4s-blaze-client, http4s-circe, ‚Ä¶ to 0.21.15 #594 (47erbot) Update sbt to 1.4.6 #593 (47erbot) Update sbt-microsites to 1.3.0 #592 (47erbot) Update cats-core to 2.3.1 #591 (47erbot) Update mdoc, sbt-mdoc to 2.2.14 #590 (47erbot) Update sbt-github, sbt-github-header, ‚Ä¶ to 0.9.0 #588 (47erbot) Update scalamock to 5.1.0 #585 (47erbot) Update sbt-tpolecat to 0.1.16 #584 (47erbot) Update sbt-ci-release to 1.5.5 #583 (47erbot) Update cats-core to 2.3.0 #582 (47erbot) Update mdoc, sbt-mdoc to 2.2.13 #581 (47erbot) Update http4s-blaze-client, http4s-circe, ‚Ä¶ to 0.21.13 #580 (47erbot) Update sbt to 1.4.4 #579 (47erbot) Update scalatest to 3.2.3 #575 (47erbot) Update mdoc, sbt-mdoc to 2.2.12 #574 (47erbot) Update http4s-blaze-client, http4s-circe, ‚Ä¶ to 0.21.9 #573 (47erbot) Update sbt-ci-release to 1.5.4 #571 (47erbot) Closed issues: Remove Auth.newAuth as it has been discontinued #597 Ignore the reviewers test #586 Receive 422 response when searching Issues #569 Merged pull requests: Add draft PRs support #577 (kusaeva) Support for review requests #576 (reimai) v0.27.1 (2020-11-17) Full Changelog v0.27.0 (2020-11-17) Full Changelog ‚ö†Ô∏è Breaking changes make accessToken an io to use gh app‚Äôs expiring tokens #567 (reimai) üìà Dependency updates Update sbt to 1.4.3 #570 (47erbot) Update sbt to 1.4.2 #566 (47erbot) Update sbt to 1.4.1 #562 (47erbot) Update scalafmt-core to 2.7.5 #561 (47erbot) Update sbt-mdoc to 2.2.10 #560 (47erbot) Update http4s-blaze-client, http4s-circe, ‚Ä¶ to 0.21.8 #559 (47erbot) Update sbt-tpolecat to 0.1.14 #558 (47erbot) Update scalafmt-core to 2.7.4 #557 (47erbot) Update sbt to 1.4.0 #556 (47erbot) Update scalafmt-core to 2.7.3 #555 (47erbot) Closed issues: Support creation of pull request reviews #563 Default value for optional field #549 Include ‚Äúpermissions‚Äù in domain objects #526 Merged pull requests: Repository model enriched: Archived status available now #565 (nihirash) Support a creation of pull request reviews #564 (kusaeva) v0.26.0 (2020-09-23) Full Changelog ‚ö†Ô∏è Breaking changes Added default value #553 (loonydev) üöÄ Features Added issue label api #547 (loonydev) üêõ Bug Fixes Fixes CreateLabel integration test #550 (juanpedromoreno) üìà Dependency updates Update scalafmt-core to 2.7.2 #552 (47erbot) Update sbt-mdoc to 2.2.9 #551 (47erbot) Update scalafmt-core to 2.7.1 #548 (47erbot) Update sbt-mdoc to 2.2.8 #546 (47erbot) Update sbt-mdoc to 2.2.7 #545 (47erbot) Update base64 to 0.2.10 #544 (47erbot) Update scalafmt-core to 2.7.0 #543 (47erbot) Update cats-core to 2.2.0 #542 (47erbot) Update sbt-mdoc to 2.2.6 #541 (47erbot) Update scalatest to 3.2.2 #540 (47erbot) Update sbt-mdoc to 2.2.5 #539 (47erbot) Update sbt-mdoc to 2.2.4 #538 (47erbot) Update http4s-blaze-client, http4s-circe, ‚Ä¶ to 0.21.7 #537 (47erbot) Update scalatest to 3.2.1 #536 (47erbot) Update sbt-scalafmt to 2.4.2 #535 (47erbot) Update scalamock to 5.0.0 #534 (47erbot) Update scalafmt-core to 2.6.4 #533 (47erbot) Update silencer-lib, silencer-plugin to 1.7.1 #532 (47erbot) Closed issues: Label id is Long, not Int #529 Merged pull requests: Apply scalafmt #531 (BenFradet) Add check if user is a collaborator #530 (zachkirlew) v0.25.0 (2020-07-16) Full Changelog ‚ö†Ô∏è Breaking changes Turn id fields into longs #523 (chalenge) üìà Dependency updates Update scalafmt-core to 2.6.3 #527 (scala-steward) Update scalafmt-core to 2.6.2 #525 (scala-steward) Update http4s-blaze-client, http4s-circe, ‚Ä¶ to 0.21.6 #522 (scala-steward) Update sbt to 1.3.13 #521 (scala-steward) Update sbt-tpolecat to 0.1.13 #520 (scala-steward) Update sbt-mdoc to 2.2.3 #519 (scala-steward) Update scalatest to 3.2.0 #514 (scala-steward) Update sbt-mdoc to 2.2.2 #511 (scala-steward) Closed issues: Getting NotFound error when using repos.createRelease api #524 Merged pull requests: Get repository permissions for a user #528 (zachkirlew) Update http4s-blaze-client, http4s-circe, ‚Ä¶ to 0.21.5 #518 (BenFradet) Update scalafmt-core to 2.6.1 #516 (BenFradet) Update scalafmt-core to 2.6.0 #513 (BenFradet) v0.24.1 (2020-06-08) Full Changelog üöÄ Features Get release by release Id #497 (georgeorfanidi) Get Blob support #494 (georgeorfanidi) Latest release #493 (georgeorfanidi) List of releases #492 (georgeorfanidi) Do not depend on the http4s blaze client #480 (BenFradet) üìà Dependency updates Update scalafmt-core to 2.5.3 #506 (scala-steward) Update sbt-mdoc to 2.2.1 #505 (scala-steward) Update sbt to 1.3.12 #504 (scala-steward) Update sbt-tpolecat to 0.1.12 #503 (scala-steward) Update scalatest to 3.1.2 #491 (scala-steward) Update sbt-mdoc to 2.2.0 #490 (scala-steward) Update http4s-blaze-client, http4s-circe to 0.21.4 #486 (scala-steward) Update sbt-ci-release to 1.5.3 #483 (scala-steward) Update sbt-microsites to 1.2.0 #482 (scala-steward) Closed issues: Remove code coverage threshold #507 Merged pull requests: Fixes oauth/access_token Interpreter #509 (juanpedromoreno) Remove code coverage threshold #508 (BenFradet) Prepare repository for next .github release and SBT build improvements #501 (alejandrohdezma) Make some Release fields optional #495 (BenFradet) Update scalafmt-core to 2.5.1 #488 (BenFradet) Perform scalafmt checks for the test code #484 (BenFradet) Adds micrositeGithubToken settings #478 (juanpedromoreno) v0.24.0 (2020-04-16) Full Changelog ‚ö†Ô∏è Breaking changes Remove default parameters from interpreters #462 (BenFradet) Uniformize pagination usage #443 (BenFradet) Error refactor #440 (BenFradet) Unseal GithubAPIs and make it part of the algebra [fixes #392] #421 (dcsobral) Introduces custom GitHub configuration #384 (satorg) Require an http4s client to provide more flexibility #373 (BenFradet) üöÄ Features Add Scaladoc API to the microsite #134 Better exception messages/classes #118 üìà Dependency updates Update sbt to 1.3.10 #468 (scala-steward) Update sbt-scalafmt to 2.3.3 #445 (scala-steward) Closed issues: Interpreters shouldn‚Äôt have default parameters #449 HttpClient should support default headers #447 Missing pagination parameter #441 Integration tests are run when the token is not present #396 Most GH error bodies are returned as JsonProcessingException. #394 Sealed GithubAPIs prevents extension #392 Add support for create / update / delete file #388 Support for private GitHub Enterprise installations #379 Shutting down connection pool info messages #371 Clarify error handling design #363 GHException extends Throwable #362 Remove list statuses test flakiness #300 Traversing with Pagination #285 Wrong API endpoint for listUserRepos #255 Add create milestone #248 Merged pull requests: Add README to the managed docs folder #474 (BenFradet) Document error handling #472 (BenFradet) Add Scaladoc to the microsite #463 (BenFradet) Add support for default headers #461 (BenFradet) Simplify SBT build and fix docs generation #456 (alejandrohdezma) Fixes mdoc docs settings #451 (juanpedromoreno) Removes sbt-org-policies #436 (juanpedromoreno) Make GHException extend Exception #430 (BenFradet) Remove sbt-org-policies dependency syntax #429 (BenFradet) Rename integration specs #428 (BenFradet) Remove mockserver dependency #427 (BenFradet) Make all case classes final #426 (BenFradet) Renames GH token env var #405 (juanpedromoreno) Updated and delete milestone #402 (anamariamv) Don‚Äôt propagate dummy configuration to integration tests #401 (BenFradet) Get single milestone #400 (anamariamv) Fix API documentation link for the user repos endpoint #399 (BenFradet) Renames Token Env Var #397 (juanpedromoreno) API: Create milestone #391 (anamariamv) feat: add Create / Update / Delete requests #390 (kalexmills) Update http4s-blaze-client, http4s-circe to 0.21.2 #387 (scala-steward) Update mockserver-netty to 5.10 #386 (scala-steward) Update sbt-microsites to 1.1.5 #383 (scala-steward) Update sbt-mdoc to 2.1.5 #382 (scala-steward) Update sbt-microsites to 1.1.4 #380 (scala-steward) Mergify: configuration update #378 (juanpedromoreno) Tag test for listing starrers as integration #376 (BenFradet) Update sbt-mdoc to 2.1.4 #375 (scala-steward) Update sbt-org-policies to 0.13.2 #374 (scala-steward) v0.23.0 (2020-03-16) Full Changelog üöÄ Features Integrate a new API: Get the list of cards for a project (given a column id) #361 Integrate a new API: Get the list of projects in a repository #360 Integrate a new API: Get the list of milestones in a project #340 Integrate a new API: Get the list of columns in a project #339 Integrate a new API: Get the list of projects in an organization #338 Closed issues: Remove unnecessary folder structure #357 Include an example using F in the docs #356 Integrate a new API: Get the list of labels in a project #341 Merged pull requests: Releases 0.23.0 #372 (juanpedromoreno) Migrates from 47deg to 47degrees GH organization #370 (juanpedromoreno) Update sbt-mdoc to 2.1.3 #369 (scala-steward) Introduce sbt-tpolecat #368 (BenFradet) Rework GHResponse to incorporate useful data on unhappy path #367 (BenFradet) Update sbt-microsites to 1.1.3 #366 (scala-steward) List repository projects #365 (anamariamv) List cards #364 (bond15) List milestone and List Labels in a project #359 (anamariamv) Example using F #358 (BenFradet) Project API #354 (anamariamv) Update cats-effect to 2.1.1 #342 (scala-steward) v0.22.0 (2020-02-28) Full Changelog üöÄ Features Integrate a new API: Get the list of teams in an organization #337 Replace HTTP client/server library #332 Rewrite algebras composition #331 Migrate http requests to hammock #157 Closed issues: Lower code coverage threshold #349 Replace tut by mdoc #329 sbt-microsites 1.0 adaptation #315 SVG logo #314 Merged pull requests: Releases 0.22.0 #355 (juanpedromoreno) Lower the minimum code coverage threshold to 75% #353 (BenFradet) Update sbt-org-policies to 0.13.1 #352 (BenFradet) Update cats-core, cats-free to 2.1.1 #351 (scala-steward) Get the list of teams in an organization. #350 (anamariamv) Update sbt-microsites to 1.1.2 #348 (scala-steward) Update scalatest to 3.1.1 #347 (scala-steward) Update http4s-blaze-client, http4s-circe to 0.21.1 #346 (scala-steward) Tagless final refactor #344 (bond15) Update circe-core, circe-generic, ‚Ä¶ to 0.13.0 #343 (scala-steward) Update sbt to 1.3.8 #336 (scala-steward) Update mockserver-netty to 5.9.0 #335 (scala-steward) Replace tut by mdoc and other clean ups #330 (BenFradet) Removes unused parameter #327 (rafaparadela) Re-formats for 2020 copyright #326 (rafaparadela) Update sbt to 1.3.7 #325 (scala-steward) Update sbt-microsites to 1.1.0 #324 (scala-steward) Update sbt to 1.3.6 #322 (scala-steward) Update cats-core, cats-free to 2.1.0 #320 (BenFradet) Active sidebar items #319 (AntonioMateoGomez) Sbt microsite adaptation #317 (AntonioMateoGomez) Avoid gem system update #316 (calvellido) Publish microsite with G4S #313 (juanpedromoreno) v0.21.0 (2019-12-18) Full Changelog üöÄ Features Add tests to github4s-scalaz #159 Closed issues: Migrate -&gt; arrows #304 Migrate Unicode Arrows #296 Deploy travis stage fails with stack overflow #294 Scala 2.13 Release #261 Update dependency org.spire-math:kind-projector:plugin-&gt;default(compile) #184 Make the integration tests skippable #178 Possible duplicity #136 Create package object to handle current imports #45 Merged pull requests: Release 0.21.0 #312 (juanpedromoreno) Cross-build Scala 2.13 #311 (juanpedromoreno) Upgrades build #310 (juanpedromoreno) Removes Scalajs &amp; Scala 2.11 support #309 (juanpedromoreno) Update sbt to 1.3.5 #306 (scala-steward) 304 migrate unicode arrows #305 (duanebester) Update mockserver-netty to 5.8.0 #303 (scala-steward) replacing unicode arrows #302 (duanebester) Tagged test as integration #301 (duanebester) Updates #298 (BenFradet) Specify additional SBT memory settings #295 (BenFradet) Mockserver 5.7.2 #293 (BenFradet) Update scalaz-concurrent to 7.2.29 #284 (scala-steward) Update sbt to 1.3.3 #283 (scala-steward) Update cats-effect to 2.0.0 #282 (scala-steward) Update mockserver-netty to 5.6.1 #281 (BenFradet) Update mockserver-netty to 3.12 #278 (scala-steward) Update cats-effect to 1.4.0 #277 (scala-steward) Update cats-core, cats-free to 1.6.1 #276 (scala-steward) Update scalaz-concurrent to 7.2.28 #275 (scala-steward) Update scalatest to 3.0.8 #274 (scala-steward) Update scalaj-http to 2.4.2 #273 (scala-steward) Update sbt to 1.3.2 #272 (scala-steward) Update sbt-scalajs, scalajs-compiler to 0.6.29 #271 (scala-steward) Update sbt-scalajs-crossproject to 0.6.1 #270 (scala-steward) Update mockserver-netty to 3.10.8 #269 (scala-steward) Update circe-core, circe-generic, ‚Ä¶ to 0.11.1 #268 (scala-steward) Update roshttp to 2.2.4 #267 (scala-steward) Update simulacrum to 0.19.0 #266 (scala-steward) Update base64 to 0.2.9 #265 (scala-steward) Update sbt-buildinfo to 0.9.0 #264 (scala-steward) Adding merge_commit_sha field to PullRequest model #260 (jdesiloniz) Added contributions field #258 (oybek) Make the integration tests skippable #257 (BenFradet) GetFollowing added to the algebra #251 (mfirry) v0.20.1 (2019-02-25) Full Changelog Closed issues: Implement the library using freestyle #57 Merged pull requests: Releases 0.20.1 #254 (juanpedromoreno) Replaces circe-jawn by circe-jackson Parser #253 (juanpedromoreno) Add cla-bot to the github4s in the wild section #252 (BenFradet) Adding missing fields to User #250 (mfirry) Update headers and sbt #247 (JesusMtnez) v0.20.0 (2018-12-27) Full Changelog üöÄ Features Add support for the list branched endpoint (47deg#231) #232 (YarekTyshchenko) Closed issues: Implement Edit a gist API #238 Implement Get a single gist API #237 Add docs for list-branches feature #234 Add support for the list user repositories endpoint #194 Merged pull requests: Build upgrade and Release 0.20.0 #243 (juanpedromoreno) Update Ruby to latest 2.3.8 for Travis CI #241 (aleksandr-vin) Add Edit gist api #240 (aleksandr-vin) Fix decoding of issue when body is null #236 (YarekTyshchenko) Fix returned type in list branches docs #235 (JesusMtnez) Introduce a way to distinguish different github errors #230 (mikegirkin) Missing microsite menu entries + broken link #229 (mkobzik) Add missing links to issue table of contents #228 (mkobzik) Fix documentation for the list available assignees endpoint #227 (BenFradet) Add support for the list available assignees endpoint #226 (mkobzik) Add support for the list outside collaborators endpoint #225 (mkobzik) List user repositories api #224 (pgabara) v0.19.0 (2018-10-04) Full Changelog Closed issues: Swap out github API urls? #222 Merged pull requests: Bump sbt-org-policies to 0.9.4 #223 (BenFradet) v0.18.8 (2018-09-04) Full Changelog Merged pull requests: Release 0.18.8 #221 (BenFradet) Add cla-bot to the Github4s in the wild section #220 (BenFradet) v0.18.7 (2018-08-20) Full Changelog Merged pull requests: Release 0.18.7 #219 (BenFradet) Add listCollaborators method #218 (asoltysik) add get tree api implementation #217 (aberey) Add dashing as an application using github4s #216 (BenFradet) v0.18.6 (2018-07-09) Full Changelog Closed issues: [cats-effect] Capture can be derived for anything that has a Sync instance #213 Merged pull requests: Release 0.18.6 #215 (BenFradet) Abstract away from cats-effect IO #214 (BenFradet) v0.18.5 (2018-06-24) Full Changelog Merged pull requests: Release 0.18.5 #212 (BenFradet) Add support for the get pull request endpoint #211 (BenFradet) Add support for the remove label endpoint #210 (BenFradet) Fix cats-effect JS tests flakiness #209 (BenFradet) Bump Scala version to 2.12.6 in travis.yml #208 (BenFradet) Add support for the add labels endpoint #207 (BenFradet) List labels endpoint #206 (BenFradet) v0.18.4 (2018-04-10) Full Changelog Closed issues: Fix LabelParam #203 Merged pull requests: Release 0.18.4 #205 (BenFradet) Change param so we are filtering by label #204 (drwlrsn) Keep circe decoders dry #202 (BenFradet) v0.18.3 (2018-03-11) Full Changelog Merged pull requests: Release 0.18.3 #201 (BenFradet) # Make body: Option\\[String\\] #200 (lloydmeta) v0.18.2 (2018-03-07) Full Changelog Closed issues: Pagination for ListPullRequests and ListPullRequestFiles #197 Merged pull requests: Releases 0.18.2 #199 (fedefernandez) Add pagination support for PullRequest ops #198 (lloydmeta) v0.18.1 (2018-02-14) Full Changelog Merged pull requests: Release 0.18.1 #196 (BenFradet) Fix Capture instances for IO and Future #195 (pepegar) v0.18.0 (2018-01-23) Full Changelog Closed issues: Unit tests are failing on Travis but not locally #189 Add function to get all comments of an issue #186 Add function to get a single issue #185 Patch should be optional on PullRequestFile #180 Issues using the combined status API #179 Merged pull requests: Release version 0.18.0 #193 (BenFradet) Bump sbt-org-policies to 0.8.22 to benefit from cats 1.0.1 and circe 0.9.1 #192 (BenFradet) Get a single issue #191 (GRBurst) Fixes Travis file #190 (juanpedromoreno) Fetch issue comments #188 (GRBurst) Make status‚Äô id a Long #183 (BenFradet) Bump ruby version in travis to fix travis build #182 (guersam) Make PullRequestFile#patch an Option[String] #181 (lloydmeta) v0.17.0 (2017-11-08) Full Changelog Closed issues: Documentation not updated #167 Merged pull requests: Bump Travis‚Äô Scala version to 2.12.4 #177 (BenFradet) Bump sbt-org-policies to 0.8.7 to benefit from cats 1.0.0-RC1 &amp; co #176 (BenFradet) Bumps sbt-org-policies in order to fix docs autopublishing issue #168 (juanpedromoreno) v0.16.0 (2017-09-25) Full Changelog Closed issues: Integration tests create a bunch of gists #149 Merged pull requests: Bump travis 2.12 version to 2.12.3 #166 (suhasgaddam) Release 0.16.0 #165 (BenFradet) Bump sbt-org-policies to 0.7.4 #164 (BenFradet) Organization API #163 (BenFradet) Support for the list organization repositories endpoint #162 (BenFradet) Support for starring-related operations #161 (BenFradet) List statuses now gives back a 404 for a non-existing ref instead of an empty list #160 (BenFradet) cats-effect module #155 (BenFradet) Make gh4s doc structure reflect gh doc structure #152 (BenFradet) Remove integration.GHGistsSpec #151 (BenFradet) v0.15.0 (2017-05-23) Full Changelog Closed issues: Rename the Authentication API to Authorization #135 Support pull request reviews #133 Missing test and docs #131 Refactor algebras #129 Support managing comments for issues #106 Update documentation / microsite #42 Merged pull requests: Releases 0.15.0 #150 (juanpedromoreno) Rename Authentication to Authorization in the doc #148 (BenFradet) Fix string interpolation in docs #147 (BenFradet) Super minor lang edits #146 (MaureenElsberry) Rename listStatus to listStatuses #145 (BenFradet) Fixes ghost users associated with pull requests, issues and comments #144 (juanpedromoreno) Microsite Enhancements #143 (juanpedromoreno) Replace updateReference‚Äôs force parameter type from Option[Boolean] to Boolean #141 (BenFradet) Upgrades tut bumping sbt-org-policies version to 0.5.0 #140 (juanpedromoreno) Add support for the read half of the PR Review API #139 (mscharley) Contributing guide #138 (BenFradet) Missing unit test #137 (AdrianRaFo) Missing Test and Docs #132 (AdrianRaFo) Refactor Algebras #130 (AdrianRaFo) Remove integration tests creating statuses #128 (BenFradet) Support Comment API #127 (AdrianRaFo) Streamlined the getting started #126 (BenFradet) v0.14.7 (2017-05-08) Full Changelog Closed issues: Put and patch are coerced to post on the JVM #119 Fix documentation for Edit an issue #107 Support the Create Pull Request API #105 Support the Notifications API #97 Unify tests #44 Merged pull requests: Upgrades sbt org policies plugin #125 (fedefernandez) Releases 0.14.7 #124 (juanpedromoreno) Arf 97 support notifications api #123 (AdrianRaFo) Make sure sbt is executable in travis #122 (BenFradet) Documentation for the gist API #121 (BenFradet) Issues API unit tests #116 (BenFradet) Unify JVM and JS tests #115 (fedefernandez) Replace issue id by issue number in the doc #114 (BenFradet) Made request success check consistent between scala and scala js #112 (BenFradet) Arf 105 create pull request api #109 (AdrianRaFo) Removes annoying compiler warnings reported by -Xlint flag #104 (juanpedromoreno) Publish Microsite automatically when merging in master branch #103 (juanpedromoreno) Documentation for the PR API #102 (BenFradet) Replace foldLeft with traverse in Decoders #101 (peterneyens) v0.14.6 (2017-04-25) Full Changelog Merged pull requests: Fixes head repo decode failure #100 (fedefernandez) List pull request files endpoint #99 (BenFradet) v0.14.5 (2017-04-24) Full Changelog Closed issues: Github4s #96 Github4s #94 Random issues on Travis #84 Merged pull requests: Releases 0.14.5 #98 (juanpedromoreno) Avoids executing create and edit issue operations #95 (fedefernandez) Doc for the issue api #93 (BenFradet) Tries to fix OOM issues. Bumps sbt version #92 (juanpedromoreno) v0.14.4 (2017-04-21) Full Changelog Closed issues: PullRequest‚Äôs head missing #89 Merged pull requests: Upgrades Project #91 (juanpedromoreno) PullRequest‚Äôs head #90 (BenFradet) Documentation for the status API #88 (BenFradet) Remove duplicated circe-parser dependency #87 (BenFradet) Updated advertised version in the readme to 0.14.3 #86 (BenFradet) v0.14.3 (2017-04-17) Full Changelog Merged pull requests: Bumps library version #85 (fedefernandez) Status API #83 (BenFradet) v0.14.2 (2017-04-10) Full Changelog Merged pull requests: Upgrades sbt-org-policies #81 (fedefernandez) v0.14.1 (2017-04-05) Full Changelog üöÄ Features Add support for getting contents #79 Merged pull requests: Adds the get contents operation #80 (fedefernandez) Upgrades sbt-org-policies plugin #78 (fedefernandez) Fixes Github token through env var #77 (juanpedromoreno) Bumps sbt-org-policies plugin version #76 (juanpedromoreno) Updates changelog #75 (fedefernandez) v0.14.0 (2017-04-03) Full Changelog Merged pull requests: Adds the create release operation #74 (fedefernandez) Updates the changelog #73 (fedefernandez) v0.13.0 (2017-03-31) Full Changelog Closed issues: Git list pull requests feature #69 Git Tag Feature #68 Merged pull requests: Updates the headers and formatting #72 (fedefernandez) Git tag feature #71 (fedefernandez) Pull request list #70 (fedefernandez) Update License #64 (anamariamv) v0.12.1 (2017-03-28) Full Changelog Merged pull requests: Adds some git methods #67 (fedefernandez) Bumps sbt-org-policies plugin version #66 (juanpedromoreno) Excludes BuildInfo class from packaging #65 (juanpedromoreno) v0.12.0 (2017-03-22) Full Changelog üöÄ Features Publish version for Scala 2.12 #40 Closed issues: Update sbt-catalyst-extras to sbt-org-policies #55 Merged pull requests: Integrates sbt-org-policies plugin and.. #63 (juanpedromoreno) v0.11.1 (2017-03-22) Full Changelog Merged pull requests: Adds rings for publish artifacts #62 (fedefernandez) Adds some optional fields to the User model #61 (fedefernandez) Update CHANGELOG.md #60 (juanpedromoreno) Fixes Docs in Travis #59 (juanpedromoreno) v0.11.0 (2017-03-16) Full Changelog Closed issues: Update dependencies #56 Migrate group id com.47deg #53 Merged pull requests: Migrates group ID #58 (juanpedromoreno) Update dependencies #54 (ghost) Update CHANGELOG.md #52 (juanpedromoreno) v0.10.0 (2017-01-09) Full Changelog üêõ Bug Fixes Sample Title #48 Merged pull requests: Makes mandatory some fields when creating issues #51 (fedefernandez) Adds a new root project to set Scala version #50 (fedefernandez) Adds create and edit methods for issues #49 (fedefernandez) Adds list and search methods for issues #47 (fedefernandez) Adds crossover for Scala 2.10 and upgrades libraries #46 (fedefernandez) Fix forced user agent in js side #43 (jdesiloniz) Updates Footer Descriptions. Bumps new version. #41 (juanpedromoreno) v0.9.0 (2016-11-04) Full Changelog Closed issues: Support Scala.js #10 Merged pull requests: Adding custom user headers at exec time #39 (jdesiloniz) Compatibility with scala-js #38 (jdesiloniz) v0.8.1 (2016-10-24) Full Changelog Merged pull requests: Upgrades sbt catalyst extras plugin #37 (juanpedromoreno) Integrates sbt-catalysts-extras and sbt-microsites plugins #35 (juanpedromoreno) Add method to create gists #34 (jdesiloniz) JP - Replaces Xor by Either type #33 (juanpedromoreno) v0.7 (2016-10-12) Full Changelog Closed issues: Add me to the repository developers #27 Enrich repository model #24 Unit testing #15 Target monad instances #14 Merged pull requests: JP - Upgrades Libraries #32 (juanpedromoreno) JP - Fetch Repo Contributors List #31 (juanpedromoreno) Update cats and circe versions #30 (ghost) Bump 0.5 release #29 (ghost) Take into account that commit authors may be null #28 (ghost) Include JSON body in JsonParsingException #26 (ghost) Enrich Repository class #25 (rafaparadela) Added the compilation of tut in TravisCI #22 (rafaparadela) Added token for codecov.io #21 (rafaparadela) Provide interpreters with several monad instances #18 (rafaparadela) Rafa 15 unit test #17 (rafaparadela) Moved/Renamed package in order to omit organization prefix #13 (rafaparadela) Microsite ++ sbt.site ++ sbt-ghpages ++ sbt-tut #11 (rafaparadela) ScalaDoc #9 (rafaparadela) Add Scalariform plugin and reformat entire project #8 (rafaparadela) Test coverage reports #7 (rafaparadela) Version 0.2-SNAPSHOT #6 (rafaparadela) v0.1 (2016-05-12) Full Changelog Merged pull requests: Fixes test #5 (rafaparadela) Remove unused implementation #3 (rafaparadela) Add setting for publishing on Sonatype #2 (rafaparadela) Adds Travis status image #1 (rafaparadela) * This Changelog was automatically generated by github_changelog_generator"
    } ,    
    {
      "title": "Contributing",
      "url": "/github4s/contributing",
      "content": "Contributing This is a small guide documenting the best way to add support for a new endpoint in Github4s. As an example, we‚Äôll assume that the endpoint listing the statuses for a specific ref of the repository API is not part of Github4s and we want Github4s to support it. Documentation for this endpoint can be found on developer.github.com. This endpoint is fairly simple; we need to make a GET request with the repository‚Äôs owner and name as well as the ref for which we want the status in the URL‚Äôs path, and Github will send us back a list of statuses. Source Domain The first step will be to define the domain for our endpoint which is just a mapping between the JSONs returned by the Github API and Github4s‚Äô own case classes. From the documentation, Github sends a list of statuses which looks like the following: [ { \"url\": \"https://api.github.com/repos/octocat/Hello-World/statuses/6dcb09b5b57875f334f61aebed695e2e4193db5e\", \"avatar_url\": \"https://github.com/images/error/hubot_happy.gif\", \"id\": 1, \"node_id\": \"MDY6U3RhdHVzMQ==\", \"state\": \"success\", \"description\": \"Build has completed successfully\", \"target_url\": \"https://ci.example.com/1000/output\", \"context\": \"continuous-integration/jenkins\", \"created_at\": \"2012-07-20T01:19:13Z\", \"updated_at\": \"2012-07-20T01:19:13Z\", \"creator\": { \"login\": \"octocat\", \"id\": 1, \"node_id\": \"MDQ6VXNlcjE=\", \"avatar_url\": \"https://github.com/images/error/octocat_happy.gif\", \"gravatar_id\": \"\", \"url\": \"https://api.github.com/users/octocat\", \"html_url\": \"https://github.com/octocat\", \"followers_url\": \"https://api.github.com/users/octocat/followers\", \"following_url\": \"https://api.github.com/users/octocat/following{/other_user}\", \"gists_url\": \"https://api.github.com/users/octocat/gists{/gist_id}\", \"starred_url\": \"https://api.github.com/users/octocat/starred{/owner}{/repo}\", \"subscriptions_url\": \"https://api.github.com/users/octocat/subscriptions\", \"organizations_url\": \"https://api.github.com/users/octocat/orgs\", \"repos_url\": \"https://api.github.com/users/octocat/repos\", \"events_url\": \"https://api.github.com/users/octocat/events{/privacy}\", \"received_events_url\": \"https://api.github.com/users/octocat/received_events\", \"type\": \"User\", \"site_admin\": false } } ] We can define our Status case class as: case class Status( url: String, avatar_url: String, id: Long, node_id: String, state: String, description: Option[String], target_url: Option[String], context: Option[String], created_at: String, updated_at: String ) We can put it in the github4s.domain package in the file corresponding to the API, here: Repository. Algebra Next, we need to extend the algebra for the corresponding API so it can support our endpoint. Because our endpoint is part of the repository API, we need to extend the Repositories[F[_]] algebra: def listStatuses( owner: String, repo: String, ref: String, headers: Map[String, String] = Map() ): F[GHResponse[List[Status]]] This code belongs to the github4s.algebras package in the file corresponding to the API, here: Repositories. Interpreter We‚Äôre now ready to make our repository interpreter deal with listStatuses: override def listStatuses( owner: String, repo: String, ref: String, headers: Map[String, String] = Map()): F[GHResponse[List[Status]]] = client.get[List[Status]](accessToken, s\"repos/$owner/$repo/commits/$ref/statuses\", headers) This method makes the HTTP call with the help of HttpClient Test Now that we‚Äôve written our source code, we‚Äôre ready to write the tests. Token The first step we need to take in order to run the tests is a valid token which we can provide through an environment variable: export GITHUB_TOKEN=aaaa You can create a token on Github: https://github.com/settings/tokens. Integration tests The integration tests are grouped by API in github4s.integration package. As a result, we‚Äôll be writing our tests in GHReposSpec: \"Repos &gt;&gt; ListStatus\" should \"return a non empty list when a valid ref is provided\" taggedAs Integration in { val response = client.use { client =&gt; Github[IO](client, accessToken).repos .listStatuses(validRepoOwner, validRepoName, validCommitSha, headers = headerUserAgent) }.unsafeRunSync() testIsRight[List[Status]](response, { r =&gt; r.nonEmpty shouldBe true }) response.statusCode shouldBe okStatusCode } it should \"return an error when an invalid ref is provided\" taggedAs Integration in { val response = client.use { client =&gt; Github[IO](client, accessToken).repos .listStatuses(validRepoOwner, validRepoName, invalidRef, headers = headerUserAgent) }.unsafeRunSync() testIsLeft(response) response.statusCode shouldBe notFoundStatusCode } Be aware that integration tests are only required for GET endpoints (not POST or PATCH) to avoid creating useless stuff on GitHub. Unit tests We can now move on to the unit tests which reside in the github4s.unit package. We‚Äôre going to test our Intepreter. Here too, the unit tests are grouped by API which means we‚Äôll be working on ReposSpec. Interpreter spec We‚Äôre just checking that our API defined above hits the right endpoint, here: s\"repos/$validRepoOwner/$validRepoName/commits/$validRefSingle/statuses\": \"Repos.listStatuses\" should \"call htppClient.get with the right parameters\" in { val response: IO[GHResponse[List[Status]]] = IO(GHResult(List(status).asRight, okStatusCode, Map.empty)) implicit val httpClientMock: HttpClient[IO] = httpClientMockGet[List[Status]]( url = s\"repos/$validRepoOwner/$validRepoName/commits/$validRefSingle/statuses\", response = response ) val repos = new RepositoriesInterpreter[IO] repos.listStatuses(validRepoOwner, validRepoName, validRefSingle, headerUserAgent) } Documentation Finally, we can add documentation to http://47deg.github.io/github4s/. Github4s uses sbt-microsites and mdoc to generate and publish its documentation. It shouldn‚Äôt come as a surprise at this point, but the documentation is grouped by API. As a result, we‚Äôll add documentation to repository.md: ### List statuses for a specific ref You can also list statuses through `listStatuses`; it take as arguments: - the repository coordinates (`owner` and `name` of the repository). - a git ref (a `SHA`, a branch `name` or a tag `name`). To list the statuses for a specific ref: {triple backtick}scala mdoc:silent val listStatuses = gh.repos.listStatuses(\"47degrees\", \"github4s\", \"heads/main\") listStatuses.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) {triple backtick} The `result` on the right is the corresponding [List[Status]][repository-scala]. See [the API doc](https://developer.github.com/v3/repos/statuses/#list-statuses-for-a-specific-ref) for full reference. Once the documentation is written, we can build it locally with: sbt \"project docs\" makeMicrosite cd docs/target/site/ &amp;&amp; jekyll serve"
    } ,    
    {
      "title": "Getting Started",
      "url": "/github4s/docs",
      "content": "Getting started API token In order to access the Github API, you will need to have an access token with the appropriate scopes (i.e. if you want to create gists, your token will need to have the gist scope). A personal token can be valid forever. However, the ones issued for Github Apps have to be re-issued every hour. To solve that issue, github4s provides AccessToken which you can hook into to provide authentication for your app using third-party libraries such as JWT implementations, for example. You can find the default implementation for static tokens in [StaticAccessToken][static-access-token-scala]. Github4s Github4s uses Tagless Final encoding. Every Github4s API call returns an F[GHResponse[A]] where F has an instance of cats.effect.Sync. GHResponse[A] contains the result A given by Github (or an error) as well as the status code and headers of the response: final case class GHResponse[A]( result: Either[GHException, A], statusCode: Int, headers: Map[String, String] ) To make HTTP calls, Github4s relies on an http4s‚Äô HTTP client which needs to be supplied as we‚Äôll see later. Here, we are making use of JavaNetClientBuilder because of its ease of use in a REPL. However, for production use you should prefer BlazeClientBuilder over it as detailed in the documentation. import cats.effect.IO import org.http4s.client.{Client, JavaNetClientBuilder} val httpClient: Client[IO] = { JavaNetClientBuilder[IO].create // You can use any http4s backend } As an introductory example, we can get a user with the following: import github4s.Github val accessToken = sys.env.get(\"GITHUB_TOKEN\") val user1 = Github[IO](httpClient, accessToken).users.get(\"rafaparadela\") user1 in this case is a IO[GHResponse[User]]. Error handling Depending on the response issued by GitHub, you might find yourself in the unhappy path of GHResponse. In this case you will have a Left as GHResponse#result which contains a GHError. The GHError ADT defines different cases based on the response‚Äôs status code: 400 maps to BadRequestError 401 -&gt; UnauthorizedError 403 -&gt; ForbiddenError 404 -&gt; NotFoundError 422 -&gt; UnprocessableEntityError 423 -&gt; RateLimitExceededError Thanks to these, you can fine-grain your logic according to your needs. E.g. if you‚Äôre hitting a RateLimitExceededError, it might be worth it to inspect the headers and wait accordingly before retrying your request. We support an extensive set of errors. However, since GitHub‚Äôs documentation regarding errors is sparse, it‚Äôs definitely possible, or rather extremly likely, that this set of supported errors is not exhaustive. If you find an unsupported error, which translates into either: UnhandledResponseError which corresponds to a status code which was not handled, or JsonParsingError which indicates that the JSON sent back by GitHub couldn‚Äôt be decoded into the case classes defined by github4s, please create an issue at https://github.com/47degrees/github4s/issues. Using different effect types Github4s supports different effect types which we will go through next. Using F[_]: cats.effect.Concurrent Any type with a cats.effect.Concurrent instance can be used with this example object ProgramF { import cats.effect.Concurrent import github4s.Github import github4s.GHResponse import github4s.domain.User import org.http4s.client.Client def u1[F[_]: Concurrent](httpClient: Client[F]): F[GHResponse[User]] = Github[F](httpClient, accessToken).users.get(\"juanpedromoreno\") } Using cats.effect.IO import cats.effect.IO import cats.effect.unsafe.implicits.global import github4s.Github import org.http4s.client.{Client, JavaNetClientBuilder} object ProgramIO { val httpClient: Client[IO] = JavaNetClientBuilder[IO].create // You can use any http4s backend val u2 = Github[IO](httpClient, accessToken).users.get(\"juanpedromoreno\") u2.unsafeRunSync() } Using Future object ProgramFuture { import cats.effect.IO import cats.effect.unsafe.implicits.global import github4s.Github import org.http4s.client.{Client, JavaNetClientBuilder} import scala.concurrent.Await import scala.concurrent.duration._ val httpClient: Client[IO] = JavaNetClientBuilder[IO].create // You can use any http4s backend val u5 = Github[IO](httpClient, accessToken).users.get(\"juanpedromoreno\").unsafeToFuture() Await.result(u5, 2.seconds) } When using capability traits (aka ‚Äútagless final‚Äù) style, you can convert any Async[F] to a Future using Dispatcher Using github4s with GitHub Enterprise By default Github instances are configured for the public GitHub endpoints via a fallback GithubConfig instance which is picked up by the Github constructor if there‚Äôs no other GithubConfig in the scope. It is also possible to pass a custom GitHub configuration (e.g. for a particular GitHub Enterprise server). To override the default configuration values declare a custom GithubConfig instance in an appropriate scope: import github4s.{Github, GithubConfig} implicit val config: GithubConfig = GithubConfig( baseUrl = \"\", // default: \"https://api.github.com/\" authorizeUrl = \"\", // default: \"https://github.com/login/oauth/authorize?client_id=%s&amp;redirect_uri=%s&amp;scope=%s&amp;state=%s\" accessTokenUrl = \"\", // default: \"https://github.com/login/oauth/access_token\" headers = Map.empty // default: Map(\"User-Agent\" -&gt; \"github4s\") ) val github = Github[IO](httpClient, None) Please refer your GitHub Enterprise server docs for exact URL values for baseUrl, authorizeUrl and accessTokenUrl. Specifying custom headers Headers are an optional field for any Github API request: object ProgramEvalWithHeaders { import cats.effect.IO import github4s.Github import org.http4s.client.{Client, JavaNetClientBuilder} val httpClient: Client[IO] = JavaNetClientBuilder[IO].create // You can use any http4s backend val userHeaders = Map(\"user-agent\" -&gt; \"github4s\") val u6 = Github[IO](accessToken).users.get(\"rafaparadela\", userHeaders) } Additionally, thanks to the aforementioned GithubConfig, it is also possible to specify custom headers which will be added to every request sent to the GitHub API. The user agent github4s is added by default."
    } ,    
    {
      "title": "Gist API",
      "url": "/github4s/gist",
      "content": "Gist API Github4s supports the Gist API. As a result, with Github4s, you can: Create a gist Get a single gist or specific revision of a gist Edit a gist The following examples assume the following code: import cats.effect.IO import github4s.Github import org.http4s.client.{Client, JavaNetClientBuilder} val httpClient: Client[IO] = JavaNetClientBuilder[IO].create // You can use any http4s backend val accessToken = sys.env.get(\"GITHUB_TOKEN\") val gh = Github[IO](httpClient, accessToken) Create a gist You can create a gist using newGist; it takes as arguments: the gist description. whether it is public or private. an association of file names and file contents where the contents are wrapped in GistFiles. To create a gist: import github4s.domain.GistFile val gistfiles = Map( \"token.scala\" -&gt; GistFile(\"val accessToken = sys.env.get(\\\"GITHUB_TOKEN\\\")\"), \"gh4s.scala\" -&gt; GistFile(\"val gh = Github(accessToken)\") ) val newGist = gh.gists.newGist(\"Github4s entry point\", public = true, gistfiles) newGist.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the created Gist. See the API doc for full reference. Get a single gist or specific revision of a gist You can create a gist using getGist; it takes as arguments: the gist id (obtained via creation of a gist, for ex.). optional sha of the gist revision. To get a single gist: val singleGist = gh.gists.getGist(\"aa5a315d61ae9438b18d\") singleGist.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) Similarly, to get a specific revision of a gist: val sepcificRevisionGist = gh.gists.getGist(\"aa5a315d61ae9438b18d\", Some(\"4e481528046a016fc11d6e7d8d623b55ea11e372\")) sepcificRevisionGist.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the requested Gist. See the API doc for full reference. Edit a gist You can edit a gist using editGist; it takes as arguments: the gist id (obtained via creation of a gist, for ex.). the gist description. an association of file names and optional file contents where the contents are wrapped in EditGistFiles, if a new file name required, then it must be provided. To edit a gist (change description, update content of token.scala, rename gh4s.scala and remove token.class file): import github4s.domain.EditGistFile val editfiles = Map( \"token.scala\" -&gt; Some(EditGistFile(\"lazy val accessToken = sys.env.get(\\\"GITHUB_TOKEN\\\")\")), \"gh4s.scala\" -&gt; Some(EditGistFile(\"val gh = Github(accessToken)\", Some(\"GH4s.scala\"))), \"token.class\" -&gt; None ) val updatedGist = gh.gists.editGist(\"aa5a315d61ae9438b18d\", \"Updated github4s entry point\", editfiles) updatedGist.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the updated Gist. See the API doc for full reference. As you can see, a few features of the gist endpoint are missing. As a result, if you‚Äôd like to see a feature supported, feel free to create an issue and/or a pull request!"
    } ,    
    {
      "title": "Git Data API",
      "url": "/github4s/git_data",
      "content": "Git Data API Github4s supports the Git Data API. As a result, with Github4s, you can: Get a Reference Create a Reference Update a Reference Get a Commit Create a Commit Get a Blob Create a Blob Get a Tree Create a Tree Create a Tag For more information on the Git object database, please read the Git Internals chapter of the Pro Git book. The following examples assume the following code: import cats.effect.IO import github4s.Github import org.http4s.client.{Client, JavaNetClientBuilder} val httpClient: Client[IO] = JavaNetClientBuilder[IO].create // You can use any http4s backend val accessToken = sys.env.get(\"GITHUB_TOKEN\") val gh = Github[IO](httpClient, accessToken) Git Data References Get a Reference The ref must be formatted as heads/branch, not just branch. For example, the call to get the data, the main branch will be heads/main. If the ref doesn‚Äôt exist in the repository, but existing refs start with ref they will be returned as an array. For example, a call to get the data for a branch named feature, which doesn‚Äôt exist, would return head refs including featureA and featureB which do. You can get a reference using getReference, it takes as arguments: the repository coordinates (owner and name of the repository). ref: ref formatted as heads/branch. pagination: Limit and Offset for pagination, optional. val getReference = gh.gitData.getReference(\"47degrees\", \"github4s\", \"heads/main\") getReference.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[Ref]. See the API doc for full reference. Create a Reference The ref must be formatted as heads/branch, not just branch. For example, the call to get the data, the main branch will be heads/main. You can create a reference using createReference; it takes as arguments: the repository coordinates (owner and name of the repository). ref: The name of the fully qualified reference (e.g.: refs/heads/main). If it doesn‚Äôt start with ‚Äòrefs‚Äô and has at least two slashes, it will be rejected. sha: the SHA1 value to set this reference. val createReference = gh.gitData.createReference( \"47deg\", \"github4s\", \"refs/heads/main\", \"d3b048c1f500ee5450e5d7b3d1921ed3e7645891\") createReference.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the created Ref. See the API doc for full reference. Update a Reference You can update a reference using updateReference; it takes as arguments: the repository coordinates (owner and name of the repository). ref: ref formatted as heads/branch. sha: the SHA1 value to set this reference. force: Indicates whether to force the update or to make sure the update is a fast-forward update. Setting it to false will make sure you‚Äôre not overwriting work. Default: false. val updateReference = gh.gitData.updateReference( \"47deg\", \"github4s\", \"heads/main\", \"d3b048c1f500ee5450e5d7b3d1921ed3e7645891\", false) updateReference.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the updated Ref. See the API doc for full reference. Commits Get a Commit You can get a commit using getCommit; it takes as arguments: the repository coordinates (owner and name of the repository). sha: the sha of the commit. val getCommit = gh.gitData.getCommit(\"47degrees\", \"github4s\", \"d3b048c1f500ee5450e5d7b3d1921ed3e7645891\") getCommit.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding RefCommit. See the API doc for full reference. Create a Commit You can create a commit using createCommit; it takes as arguments: the repository coordinates (owner and name of the repository). message: the new commit‚Äôs message. tree: the SHA of the tree object this commit points to. parents: the SHAs of the commits that are the parents of this commit. If omitted or empty, the commit will be written as a root commit. For a single parent, an array of one SHA should be provided; for a merge commit, an array of more than one should be provided. author: object containing information about the author. val createCommit = gh.gitData.createCommit( \"47deg\", \"github4s\", \"New access token\", \"827efc6d56897b048c772eb4087f854f46256132\", List(\"d3b048c1f500ee5450e5d7b3d1921ed3e7645891\"), None) createCommit.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the created RefCommit. See the API doc for full reference. Blobs Get a Blob You can get a blob using getBlob; it takes as arguments: the repository coordinates (owner and name of the repository). sha: the sha of the blob. val getBlob = gh.gitData.getBlob(\"47degrees\", \"github4s\", \"d3b048c1f500ee5450e5d7b3d1921ed3e7645891\") getBlob.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding BlobContent. See the API doc for full reference. Create a Blob You can create a blob using createBlob; it takes as arguments: the repository coordinates (owner and name of the repository). content: the new blob‚Äôs content. encoding: the encoding used for content. Currently, ‚Äúutf-8‚Äù and ‚Äúbase64‚Äù are supported. Default: ‚Äúutf-8‚Äù. val createBlob = gh.gitData.createBlob(\"47degrees\", \"github4s\", \"New access token\", Some(\"utf-8\")) createBlob.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the created RefObject. See the API doc for full reference. Trees As you probably know, Git can be considered as a tree structure. Each commit creates a new node in that tree. We can even assume that all the Git commands or methods provided by the API are just tools to navigate this tree and to manipulate it. In the following sections, we‚Äôll see how Github4s provides methods to wrap the Git API. Get a Tree You can get a tree using getTree; it takes as arguments: the repository coordinates (owner and name of the repository). sha: the sha of the commit. recursive: flag whether to get the tree recursively. val getTree = gh.gitData.getTree(\"47degrees\", \"github4s\", \"d3b048c1f500ee5450e5d7b3d1921ed3e7645891\", true) getTree.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding TreeResult. See the API doc for full reference. Create a Tree The tree creation API will take nested entries as well. If both a tree and a nested entries modifying that tree are specified, it will overwrite the contents of that tree with the new path contents write out a new tree. IMPORTANT: If you don‚Äôt set ¬¥baseTree¬¥, the commit will be created on top of everything; however, it will only contain your changes, the rest of your files will show up as deleted. You can create a tree using createTree; it takes as arguments: the repository coordinates (owner and name of the repository). baseTree: the SHA1 of the tree you want to update with new data. treeDataList: list (of path, mode, type, and sha/blob) specifying a tree structure. path: The file referenced in the tree. mode: The file mode; one of 100644 for file (blob), 100755 for executable (blob), 040000 for subdirectory (tree), 160000 for submodule (commit), or 120000 for a blob that specifies the path of a symlink. type: Either blob, tree, or commit. sha: The SHA1 checksum ID of the object in the tree. content: The content you want this file to have. GitHub will write this blob out and use that SHA for this entry. Use either this or tree.sha. import github4s.domain.TreeDataSha val createTree = gh.gitData.createTree( \"47deg\", \"github4s\", Some(\"827efc6d56897b048c772eb4087f854f46256132\"), List(TreeDataSha( \"project/plugins.sbt\", \"100644\", \"blob\", \"827efc6d56897b048c772eb4087f854f46256132\"))) createTree.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the created TreeResult. See the API doc for full reference. Tag Create a Tag You can create a tag using createTag; it takes as arguments: the repository coordinates (owner and name of the repository). tag: the tag. message: the new tag message. objectSha: the SHA of the git object this is tagging. objectType: the type of the object we‚Äôre tagging. Normally this is a commit, but it can also be a tree or a blob. tagger: Optional object containing information about the individual creating the tag. import github4s.domain.RefAuthor val createTag = gh.gitData.createTag( \"47deg\", \"github4s\", \"v0.1.1\", \"New access token\", \"d3b048c1f500ee5450e5d7b3d1921ed3e7645891\", \"commit\", Some(RefAuthor(\"2014-11-07T22:01:45Z\", \"rafaparadela\", \"developer@47deg.com\"))) createTag.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the created Tag. See the API doc for full reference. As you can see, a few features of the git data endpoint are missing. As a result, if you‚Äôd like to see a feature supported, feel free to create an issue and/or a pull request!"
    } ,    
    {
      "title": "Home",
      "url": "/github4s/",
      "content": "Github4s Github4s is a GitHub API wrapper written in Scala. Installation To get started with SBT, simply add the following to your build.sbt file. libraryDependencies += \"com.47deg\" %% \"github4s\" % \"0.31.1\""
    } ,    
    {
      "title": "Issue API",
      "url": "/github4s/issue",
      "content": "Issue API Github4s supports the Issue API. As a result, with Github4s, you can interact with: Issues Create an issue Edit an issue List issues Get a single issue Search issues Comments List comments Create a comment Edit a comment Delete a comment Labels List labels for this repository Create a label Update a label Delete a label List labels Add labels Remove a label Assignees List available assignees Milestones List milestones for a respository Get a single milestone Create milestone Update a milestone Delete a milestone The following examples assume the following code: import cats.effect.IO import github4s.Github import github4s.domain.Label import org.http4s.client.{Client, JavaNetClientBuilder} val httpClient: Client[IO] = JavaNetClientBuilder[IO].create // You can use any http4s backend val accessToken = sys.env.get(\"GITHUB_TOKEN\") val gh = Github[IO](httpClient, accessToken) Issues Create an issue You can create an issue using createIssue; it takes as arguments: the repository coordinates (owner and name of the repository). the content of the issue (title and body). other optional parameters: milestone id, labels and assignees which are only taken into account if you have push access to the repository. To create an issue: val createIssue = gh.issues.createIssue(\"47degrees\", \"github4s\", \"Github4s\", \"is awesome\", None, List(\"Label\"), List(\"Assignee\")) createIssue.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the created Issue. See the API doc for full reference. Edit an issue You can edit an existing issue using editIssue; it takes as arguments: the repository coordinates (owner and name of the repository). the issue number. the updated state of the issue (open or closed). the edited content of the issue (title and body). other optional parameters: milestone id, labels and assignees which are only taken into account if you have push access to the repository. To edit an issue: val editIssue = gh.issues.editIssue(\"47degrees\", \"github4s\", 1, \"open\", \"Github4s\", \"is still awesome\", None, List(\"Label\"), List(\"Assignee\")) editIssue.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) the result on the right is the edited Issue. See the API doc for full reference. List issues You can also list issues for a repository through listIssues; it takes as arguments: the repository coordinates (owner and name of the repository). pagination: Limit and Offset for pagination, optional. To list the issues for a repository: val listIssues = gh.issues.listIssues(\"47degrees\", \"github4s\") listIssues.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[Issue]. Note that it will contain pull requests as Github considers pull requests as issues. See the API doc for full reference. Get a single issue You can also get a single issue of a repository through getIssue; it takes as arguments: the repository coordinates (owner and name of the repository). number: The issue number. To get a single issue from a repository: val issue = gh.issues.getIssue(\"47degrees\", \"github4s\", 17) issue.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding Issue. Note that it will return pull requests as Github considers pull requests as issues. See the API doc for full reference. Search issues Lastly, you can also search issues all across Github thanks to searchIssues; it takes as arguments: a query string (the URL encoding is taken care of by Github4s). a list of SearchParam. Let‚Äôs say we want to search for the Scala bugs (https://github.com/scala/bug) which contain the ‚Äúexistential‚Äù keyword in their title: import github4s.domain._ val searchParams = List( OwnerParamInRepository(\"scala/bug\"), IssueTypeIssue, SearchIn(Set(SearchInTitle)) ) val searchIssues = gh.issues.searchIssues(\"existential\", searchParams) searchIssues.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is a SearchIssuesResult. See the API doc for full reference. Comments List comments You can list comments of an issue with the following parameters: the repository coordinates (owner and name of the repository). number: The issue number. pagination: Limit and Offset for pagination, optional. To list comments: val commentList = gh.issues.listComments(\"47degrees\", \"github4s\", 17) commentList.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[Comment] See the API doc for full reference. Create a comment You can create a comment for an issue with the following parameters: the repository coordinates (owner and name of the repository). number: The issue number. body: The comment description. To create a comment: val createcomment = gh.issues.createComment(\"47degrees\", \"github4s\", 17, \"this is the comment\") createcomment.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is a Comment. See the API doc for full reference. Edit a comment You can edit a comment from an issue with the following parameters: the repository coordinates (owner and name of the repository). id: The comment id. body: The new comment description. To edit a comment: val editComment = gh.issues.editComment(\"47degrees\", \"github4s\", 20, \"this is the new comment\") editComment.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is a Comment. See the API doc for full reference. Delete a comment You can delete a comment from an issue with the following parameters: the repository coordinates (owner and name of the repository). id: The comment id. To delete a comment: val deleteComment = gh.issues.deleteComment(\"47degrees\", \"github4s\", 20) deleteComment.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is Unit. See the API doc for full reference. Labels List labels for this repository You can list labels for an issue with the following parameters: the repository coordinates (owner and name of the repository). pagination: Limit and Offset for pagination, optional. To list labels: val labelListRepository = gh.issues.listLabelsRepository(\"47degrees\", \"github4s\") labelListRepository.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[Label] See the API doc for full reference. Create a label You can create label for an repository with the following parameters: the repository coordinates (owner and name of the repository). label: Label for create (name, color and optional field desctiption) To create label: val label = Label( name = \"bug\", color = \"ffffff\", id = None, description = None, url = None, default = None ) val createLabel = gh.issues.createLabel(\"47degrees\", \"github4s\", label) createLabel.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding created Label See the API doc for full reference. Update a label You can update existing label for an repository with the following parameters: the repository coordinates (owner and name of the repository). label: Label for update (name, color and optional field desctiption) To update label: val label = Label( name = \"bug\", color = \"ffffff\", id = None, description = None, url = None, default = None ) val updateLabel = gh.issues.updateLabel(\"47degrees\", \"github4s\", label) updateLabel.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding updated Label See the API doc for full reference. Delete a label You can delete existing label for an repository with the following parameters: the repository coordinates (owner and name of the repository). label: The existing label name To delete label: val deleteLabel = gh.issues.deleteLabel(\"47degrees\", \"github4s\", \"bug\") deleteLabel.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is Unit. See the API doc for full reference. List labels You can list labels for an issue with the following parameters: the repository coordinates (owner and name of the repository). number: The issue number. pagination: Limit and Offset for pagination, optional. To list labels: val labelList = gh.issues.listLabels(\"47degrees\", \"github4s\", 17) labelList.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[Label] See the API doc for full reference. Add labels You can add existing labels to an issue with the following parameters: the repository coordinates (owner and name of the repository). number: The issue number. labels: The existing labels that require adding. To add existing labels to an issue: val assignedLabelList = gh.issues.addLabels(\"47degrees\", \"github4s\", 17, List(\"bug\", \"code review\")) assignedLabelList.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding assigned List[Label] See the API doc for full reference. Remove a label You can remove a label from an issue with the following parameters: the repository coordinates (owner and name of the repository). number: The issue number. label: The label that requires removing. To remove an existing label from an issue: val removedLabelList = gh.issues.removeLabel(\"47degrees\", \"github4s\", 17, \"bug\") removedLabelList.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding removed List[Label] See the API doc for full reference. Assignees List available assignees You can list available assignees for issues in repo with the following parameters: the repository coordinates (owner and name of the repository). pagination: Limit and Offset for pagination, optional. To list available assignees: val assignees = gh.issues.listAvailableAssignees(\"47degrees\", \"github4s\") assignees.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[User] See the API doc for full reference. As you can see, a few features of the issue endpoint are missing. As a result, if you‚Äôd like to see a feature supported, feel free to create an issue and/or a pull request! Milestones List milestones for a repository You can list the milestone for a particular organization and repository with listMilestones; it takes arguments: owner: name of the owner for which we want to retrieve the milestones. repo: name of the repository for which we want to retrieve the milestones. state: filter projects returned by their state. Can be either open, closed, all. Default: open, optional sort: what to sort results by. Either due_on or completeness. Default: due_on, optional direction the direction of the sort. Either asc or desc. Default: asc, optional pagination: Limit and Offset for pagination, optional. header: headers to include in the request, optional. To list the milestone for owner 47deg and repository github4s: val milestones = gh.issues.listMilestones(\"47degrees\", \"github4s\", Some(\"open\"), None, None) milestones.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[Milestone] See the API doc for full reference. Create milestone You can create a milestone for a particular organization and repository with createMilestone; it takes arguments: owner: name of the owner for which we want to create the milestones. repo: name of the repository for which we want to create the milestones. state: The state of the milestone. Either open or closed. Default: open, optional title: The title of the milestone. description: A description of the milestone, optional due_on: The milestone due date. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ, optional. header: headers to include in the request, optional. To create a milestone for owner 47deg and repository github4s: val milestone = gh.issues.createMilestone(\"47degrees\", \"github4s\", \"New milestone\",Some(\"open\"), None, None) milestone.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding Milestone See the API doc for full reference. Get a single milestone You can also get a single milestone of a repository through getMilestone; it takes as arguments: owner: name of the owner for which we want to retrieve the milestones. repo: name of the repository for which we want to retrieve the milestones. number: The milestone number. header: headers to include in the request, optional. To get milestone number 3254 for owner 47deg and repository github4s: val milestone = gh.issues.getMilestone(\"47degrees\", \"github4s\", 32) milestone.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding Milestone See the API doc for full reference. Update a milestone You can update a milestone for a particular organization and repository with updateMilestone; it takes arguments: owner: name of the owner for which we want to create the milestones. repo: name of the repository for which we want to create the milestones. milestone_number: number of milestone. state: The state of the milestone. Either open or closed. Default: open, optional title: The title of the milestone. description: A description of the milestone, optional due_on: The milestone due date. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ, optional. header: headers to include in the request, optional. To update a milestone for owner 47deg and repository github4s: val milestone = gh.issues.updateMilestone(\"47degrees\", \"github4s\", 1 , \"New milestone\", Some(\"open\"), None, None) milestone.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding Milestone See the API doc for full reference. Delete a milestone You can delete a milestone for a particular organization and repository with deleteMilestone; it takes arguments: owner: name of the owner for which we want to create the milestones. repo: name of the repository for which we want to create the milestones. milestone_number: number of milestone header: headers to include in the request, optional. To delete a milestone for owner 47deg and repository github4s: val milestone = gh.issues.deleteMilestone(\"47degrees\", \"github4s\", 1) milestone.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is Unit. See the API doc for full reference."
    } ,      
    {
      "title": "Organization API",
      "url": "/github4s/organization",
      "content": "Organization API Github4s supports the Organization API. As a result, with Github4s, you can interact with: Members List members Outside Collaborators List outside collaborators The following examples assume the following code: import cats.effect.IO import github4s.Github import org.http4s.client.{Client, JavaNetClientBuilder} val httpClient: Client[IO] = JavaNetClientBuilder[IO].create // You can use any http4s backend val accessToken = sys.env.get(\"GITHUB_TOKEN\") val gh = Github[IO](httpClient, accessToken) Members List members You can list the members for a particular organization with listMembers; it takes as arguments: org: name of the organization for which we want to retrieve the members. filter: to retrieve ‚Äúall‚Äù or only ‚Äú2fa_disabled‚Äù users, optional. role: to retrieve ‚Äúall‚Äù, only non-owners (‚Äúmember‚Äù) or only owners (‚Äúadmin‚Äù), optional. pagination: Limit and Offset for pagination, optional. To list the members for organization 47deg: val listMembers = gh.organizations.listMembers(\"47deg\") listMembers.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[User]. See the API doc for full reference. Outside Collaborators List outside collaborators You can list the outside collaborators of your organization with listOutsideCollaborators; it takes as arguments: org: name of the organization for which we want to retrieve the outside collaborators. filter: to retrieve ‚Äúall‚Äù or only ‚Äú2fa_disabled‚Äù users, optional. pagination: Limit and Offset for pagination, optional. To list the outside collaborators for organization 47deg: val outsideCollaborators = gh.organizations.listOutsideCollaborators(\"47deg\") outsideCollaborators.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[User]. See the API doc for full reference. As you can see, a few features of the organization endpoint are missing. As a result, if you‚Äôd like to see a feature supported, feel free to create an issue and/or a pull request!"
    } ,    
    {
      "title": "Project API",
      "url": "/github4s/project",
      "content": "Project API Note: The Projects API is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details. To access the API during the preview period, you must provide a custom media type in the Accept header: application/vnd.github.inertia-preview+json Github4s supports the Project API. As a result, with Github4s, you can interact with: Project List repository projects List projects Columns List project columns Cards List project cards The following examples assume the following code: import cats.effect.IO import github4s.Github import org.http4s.client.{Client, JavaNetClientBuilder} val httpClient: Client[IO] = JavaNetClientBuilder[IO].create // You can use any http4s backend val accessToken = sys.env.get(\"GITHUB_TOKEN\") val gh = Github[IO](httpClient, accessToken) Project List repository projects You can list the projects for a particular repository with listProjectsRepository; it takes as arguments: owner: name of the owner for which we want to retrieve the projects. repo: name of the repository for which we want to retrieve the projects. state: filter projects returned by their state. Can be either open, closed, all. Default: open, optional pagination: Limit and Offset for pagination, optional. header: headers to include in the request, optional. To list the projects for owner 47deg and repository github4s: val listProjectsRepository = gh.projects.listProjectsRepository( owner = \"47deg\", repo = \"github4s\", headers = Map(\"Accept\" -&gt; \"application/vnd.github.inertia-preview+json\")) listProjectsRepository.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[Project]. See the API doc for full reference. List projects You can list the project for a particular organization with listProjects; it takes as arguments: org: name of the organization for which we want to retrieve the projects. state: filter projects returned by their state. Can be either open, closed, all. Default: open, optional pagination: Limit and Offset for pagination, optional. header: headers to include in the request, optional. To list the projects for organization 47deg: val listProjects = gh.projects.listProjects( org = \"47deg\", headers = Map(\"Accept\" -&gt; \"application/vnd.github.inertia-preview+json\")) listProjects.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[Project]. See the API doc for full reference. Columns List project columns You can list the columns for a particular project with listColumns; it takes as arguments: project_id: project id for which we want to retrieve the columns. pagination: Limit and Offset for pagination, optional. header: headers to include in the request, optional. To list the columns for project_id 1910444: val listColumns = gh.projects.listColumns( project_id = 1910444, headers = Map(\"Accept\" -&gt; \"application/vnd.github.inertia-preview+json\")) listColumns.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[Column]. See the API doc for full reference. Cards List project cards by column You can list the cards for a particular column with listCards; it takes as arguments: column_id: column id for which we want to retrieve the cards. archived_state: filters the project cards that are returned by the card‚Äôs state. Can be one of all,archived, or not_archived. Default: not_archived, optional. pagination: Limit and Offset for pagination, optional. header: headers to include in the request, optional. To list the columns for project_id 8271018: val listCards = gh.projects.listCards( column_id = 8271018, headers = Map(\"Accept\" -&gt; \"application/vnd.github.inertia-preview+json\")) listCards.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[Card]. See the API doc for full reference."
    } ,    
    {
      "title": "Pull Request API",
      "url": "/github4s/pull_request",
      "content": "Pull Request API Github4s supports the Pull Request API. As a result, with Github4s, you can interact with: Pull requests Get a pull request List pull requests List the files in a pull request Create a pull request Update branch Reviews List reviews Get a review Create a review Review requests Add reviewers List reviewers Remove reviewers The following examples assume the following code: import cats.effect.IO import github4s.Github import org.http4s.client.{Client, JavaNetClientBuilder} val httpClient: Client[IO] = JavaNetClientBuilder[IO].create // You can use any http4s backend val accessToken = sys.env.get(\"GITHUB_TOKEN\") val gh = Github[IO](httpClient, accessToken) Pull requests Get a pull request You can get a single pull request for a repository using get; it takes as arguments: the repository coordinates (owner and name of the repository). the pull request number To get a single pull request: val getPullRequest = gh.pullRequests.getPullRequest(\"47degrees\", \"github4s\", 102) getPullRequest.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding PullRequest. See the API doc for full reference. List pull requests You can list the pull requests for a repository using list; it takes as arguments: the repository coordinates (owner and name of the repository). a list of PRFilter. As an example, let‚Äôs say we want the open pull requests in https://github.com/scala/scala sorted by popularity: import github4s.domain._ val prFilters = List(PRFilterOpen, PRFilterSortPopularity) val listPullRequests = gh.pullRequests.listPullRequests(\"scala\", \"scala\", prFilters) listPullRequests.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the matching List[PullRequest]. See the API doc for full reference. List the files in a pull request You can also list the files for a pull request using listFiles; it takes as arguments: the repository coordinates (owner and name of the repository). the pull request number. To list the files for a pull request: val listPullRequestFiles = gh.pullRequests.listFiles(\"47degrees\", \"github4s\", 102) listPullRequestFiles.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) the result on the right is the List[PullRequestFile]. See the API doc for full reference. Create a pull request If you want to create a pull request, we can follow two different methods. On the one hand, we can pass the following parameters: the repository coordinates (owner and name of the repository). title (as part of the NewPullRequestData object): Title for the pull request. body (as part of the NewPullRequestData object): Description for the pull request. head: The name of the branch where your changes are implemented. base: The name of the branch you want the changes pulled into. maintainerCanModify: Optional. Indicates whether maintainers can modify the pull request. true by default. import github4s.domain.NewPullRequestData val createPullRequestData = gh.pullRequests.createPullRequest( \"47deg\", \"github4s\", NewPullRequestData(\"title\", \"body\", draft = false), \"my-branch\", \"base-branch\", Some(true)) createPullRequestData.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) On the other hand, we can pass an issue id (through NewPullRequestIssue object) instead of the title and body. NOTE: This option deletes the issue. import github4s.domain.NewPullRequestIssue val createPullRequestIssue = gh.pullRequests.createPullRequest( \"47deg\", \"github4s\", NewPullRequestIssue(105), \"my-branch\", \"base-branch\", Some(true)) createPullRequestIssue.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) See the API doc for full reference. Update a pull request branch Merges the base HEAD into your pull request branch. Note that this is an experimental API, meaning github could stop supporting it at any time or change in an incompatible way. Accepts these parameters: the repository coordinates (owner and name of the repository). pullRequest: integer id of you pr. expectedHeadSha: The expected SHA of the pull request‚Äôs HEAD ref for an optional check on github‚Äôs side. import github4s.domain.BranchUpdateResponse val updatePullRequestBranch = gh.pullRequests.updateBranch( \"47deg\", \"github4s\", 567) updatePullRequestBranch.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) See the API doc for full reference. Reviews List pull request reviews You can list the reviews for a pull request using listReviews; it takes as arguments: the repository coordinates (owner and name of the repository). the pull request id. As an example, if we wanted to see all the reviews for pull request 139 of 47degrees/github4s: val listReviews = gh.pullRequests.listReviews( \"47deg\", \"github4s\", 139) listReviews.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the matching List[PullRequestReview]. See the API doc for full reference. Get an individual review You can get an individual review for a pull request using getReview; it takes as arguments: the repository coordinates (owner and name of the repository). the pull request id. the review id. As an example, if we wanted to see review 39355613 for pull request 139 of 47degrees/github4s: val review = gh.pullRequests.getReview( \"47deg\", \"github4s\", 139, 39355613) review.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the matching PullRequestReview. See the API doc for full reference. Create a review You can create a review for a pull request using createReview; it takes as arguments: the repository coordinates (owner and name of the repository). the pull request id. commit_id (as part of the CreatePRReviewRequest object): The SHA of the commit that needs a review. Defaults to the most recent commit. body (as part of the CreatePRReviewRequest object): Required when using REQUEST_CHANGES or COMMENT for the event parameter. The body text of the pull request review. event (as part of the CreatePRReviewRequest object): The review action you want to perform. By leaving this blank, you set the review action state to PENDING. comments (as part of the CreatePRReviewRequest object): An optional list of draft review comments. import github4s.domain.{CreatePRReviewRequest, PRREventApprove} val createReviewData = gh.pullRequests.createReview( \"47deg\", \"github4s\", 139, CreatePRReviewRequest(Some(\"commit_id\"), \"body\", PRREventApprove) ) createReviewData.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the created PullRequestReview. See the API doc for full reference. Review requests This API allows you to operate on review requests. Reviewers can be users and/or teams. Usernames should be used without a leading ‚Äò@‚Äô sign. Add reviewers You can add reviewers for a pull request using addReviewers; it takes as arguments: the repository coordinates (owner and name of the repository). the pull request id. users and teams you want to add as reviewers As an example, if we wanted to add torvalds to the reviewers for pull request 139 of 47degrees/github4s: import github4s.domain._ val addReviewers = gh.pullRequests.addReviewers( \"47deg\", \"github4s\", 139, ReviewersRequest(List(\"torvalds\"))) addReviewers.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the updated PullRequest. NOTE: you can‚Äôt request a review from the pr‚Äôs author. If your list of added reviewers contains the author, the whole request will be declined. See the API doc for full reference. List reviewers You can list the reviewers for a pull request using listReviewers; it takes as arguments: the repository coordinates (owner and name of the repository). the pull request id. As an example, if we wanted to see all the reviewers for pull request 139 of 47degrees/github4s: val listReviewers = gh.pullRequests.listReviewers( \"47deg\", \"github4s\", 139) listReviewers.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the matching ReviewersResponse, which contains all users and teams, whose review has been requested. See the API doc for full reference. Remove reviewers You can remove reviewers from a pull request using removeReviewers; it takes as arguments: the repository coordinates (owner and name of the repository). the pull request id. users and teams you want to remove from reviewers As an example, if we wanted to remove torvalds from the reviewers for pull request 139 of 47degrees/github4s: import github4s.domain._ val removeReviewers = gh.pullRequests.removeReviewers( \"47deg\", \"github4s\", 139, ReviewersRequest(List(\"torvalds\"))) removeReviewers.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the updated PullRequest. See the API doc for full reference. As you can see, a few features of the pull request endpoint are missing. As a result, if you‚Äôd like to see a feature supported, feel free to create an issue and/or a pull request!"
    } ,    
    {
      "title": "Repository API",
      "url": "/github4s/repository",
      "content": "Repository API Github4s supports the Repository API. As a result, with Github4s, you can interact with: Repositories Get a repository Search repositories List organization repositories List user repositories List contributors List collaborators Check user is a repository collaborator Get repository permissions for a user Commits List commits on a repository Compare commits on a repository Contents Get contents Create a File Update a File Delete a File Releases List of releases Get a single release The latest release Create a release Statuses Create a status List statuses for a specific Ref Get the combined status of a specific Ref The following examples assume the following code: import cats.effect.IO import github4s.Github import org.http4s.client.{Client, JavaNetClientBuilder} val httpClient: Client[IO] = JavaNetClientBuilder[IO].create // You can use any http4s backend val accessToken = sys.env.get(\"GITHUB_TOKEN\") val gh = Github[IO](httpClient, accessToken) Repositories Get a repository You can get a repository using get; it takes as arguments: the repository coordinates (owner and name of the repository). To get a repository: val getRepo = gh.repos.get(\"47degrees\", \"github4s\") getRepo.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the get Repository. See the API doc for full reference. Search repositories You can globally search repositories using searchRepos; it takes as arguments: a query string (the URL encoding is taken care of by Github4s). a list of SearchParam. pagination: Limit and Offset for pagination. To search repositories on GitHub: val searchRepos = gh.repos.searchRepos(\"github4s\", Nil) searchRepos.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) List organization repositories You can retrieve the list of repositories for a particular organization using listOrgRepos; it takes as arguments: org: The organization name. type: The optional type of the returned repositories, can be ‚Äúall‚Äù, ‚Äúpublic‚Äù, ‚Äúprivate‚Äù, ‚Äúforks‚Äù, ‚Äúsources‚Äù or ‚Äúmember‚Äù, defaults to ‚Äúall‚Äù. pagination: Limit and Offset for pagination. To list the repositories for an organization: val listOrgRepos = gh.repos.listOrgRepos(\"47deg\") listOrgRepos.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[Repository]. See the API doc for full reference. List user repositories You can retrieve the list of repositories for a particular user using listUserRepos; it takes as arguments: user: The user name. type: The optional type of the returned repositories, can be ‚Äúall‚Äù, ‚Äúowner‚Äù or ‚Äúmember‚Äù, defaults to ‚Äúowner‚Äù. pagination: Limit and Offset for pagination. To list the repositories for a user: val listUserRepos = gh.repos.listUserRepos(\"rafaparadela\") listUserRepos.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[Repository]. See the API doc for full reference. List contributors List contributors to the specified repository, sorted by the number of commits per contributor in descending order. You can list contributors using listContributors, it takes as arguments: the repository coordinates (owner and name of the repository). anon Set to 1 or true to include anonymous contributors in results. pagination: Limit and Offset for pagination, optional. To list contributors: val listContributors = gh.repos.listContributors(\"47degrees\", \"github4s\", Some(\"true\")) listContributors.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[User]. See the API doc for full reference. List collaborators List collaborators in the specified repository. You can list collaborators using listCollaborators, it takes as arguments: the repository coordinates (owner and name of the repository). affiliation, one of outside, direct, or all (default all). For more information take a look at the API doc. pagination: Limit and Offset for pagination, optional. val listCollaborators = gh.repos.listCollaborators(\"47degrees\", \"github4s\", Some(\"all\")) listCollaborators.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[User]. See the API doc for full reference. Check if a user is a repository collaborator Returns whether a given user is a repository collaborator or not. val userIsCollaborator = gh.repos.userIsCollaborator(\"47degrees\", \"github4s\", \"rafaparadela\") userIsCollaborator.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is Boolean See the API doc for full reference. Get repository permissions for a user Checks the repository permission of a collaborator. The possible repository permissions are admin, write, read, and none. val userRepoPermission = gh.repos.getRepoPermissionForUser(\"47degrees\", \"github4s\", \"rafaparadela\") userRepoPermission.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding UserRepoPermission. See the API doc for full reference. Commits List commits on a repository You can list commits using listCommits, it takes as arguments: the repository coordinates (owner and name of the repository). SHA or branch to start listing commits from. Default: the repository‚Äôs default branch (usually main). path: Only commits containing this file path will be returned. author: GitHub login or email address by which to filter by commit author. since: Only commits after this date will be returned. Format: ‚ÄúYYYY-MM-DDTHH:MM:SSZ‚Äù. until: Only commits before this date will be returned. Format: ‚ÄúYYYY-MM-DDTHH:MM:SSZ‚Äù. pagination: Limit and Offset for pagination. To list commits: val listCommits = gh.repos.listCommits( \"47deg\", \"github4s\", Some(\"d3b048c1f500ee5450e5d7b3d1921ed3e7645891\"), Some(\"README.md\"), Some(\"developer@47deg.com\"), Some(\"2014-11-07T22:01:45Z\"), Some(\"2014-11-07T22:01:45Z\")) listCommits.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[Commit]. See the API doc for full reference. Compare commits on a repository You can compare two commits using compareCommits, it takes as arguments: the repository coordinates (owner and name of the repository). commitSha or branch to identify the commit you want to check. baseSha: or branch you‚Äôre comparing the commitSha against To compare commits: val compareCommits = gh.repos.compareCommits( \"47deg\", \"github4s\", \"d3b048c1f500ee5450e5d7b3d1921ed3e7645891\", \"main\") compareCommits.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[CommitComparisonResponse]. See the API doc for full reference. Branches List branches on a repository You can list branches using listBranches, it takes as arguments: the repository coordinates (owner and name of the repository). protected Only protected branches. pagination: Limit and Offset for pagination, optional. To list branches: val listBranches = gh.repos.listBranches( \"47deg\", \"github4s\") listBranches.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[Branch]. See the API doc for full reference. Contents Get contents This method returns the contents of a file or directory in a repository. You can get contents using getContents, it takes as arguments: the repository coordinates (owner and name of the repository). path: The content path. ref: The name of the commit/branch/tag. Default: the repository‚Äôs default branch (usually main). pagination: Limit and Offset for pagination, optional. To get contents: val getContents = gh.repos.getContents(\"47degrees\", \"github4s\", \"README.md\", Some(\"s/main\")) getContents.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding NonEmptyList[Content]. See the API doc for full reference. Create a File This method creates a new file in an existing repository. You can create a new file using createFile, it takes as arguments: the repository coordinates (owner and name of the repository). path: The path of the new file to be created, without a leading slash. message: The message to use for creating the commit. content: The content of the new file, as an array of bytes. branch: The branch to add the commit to. If omitted, this defaults to the repository‚Äôs default branch. committer: An optional committer to associate with the commit. If omitted, the authenticated user‚Äôs information is used for the commit. author: An optional author to associate with the commit. If omitted, the committer is used (if present). To create a file: val getContents = gh.repos.createFile(\"47degrees\", \"github4s\", \"new-file.txt\", \"create a new file\", \"file contents\".getBytes) getContents.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"We could not create your file because ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) See the API doc for full reference. Update a File This method updates an existing file in a repository. You can update a file using updateFile, it takes as arguments: the repository coordinates (owner and name of the repository). path: The path of the new file to be created, without a leading slash. message: The message to use for creating the commit. content: The content of the new file, as an array of bytes. sha: The blob SHA of the file being replaced. (This is returned as part of a getContents call). GitHub uses this value to perform optimistic locking. If the file has been updated since, the update call will fail. branch: The branch to add the commit to. If omitted, this defaults to the repository‚Äôs default branch. committer: An optional committer to associate with the commit. If omitted, the authenticated user‚Äôs information is used for the commit. author: An optional author to associate with the commit. If omitted, the committer is used (if present). To update a file: val getContents = gh.repos.updateFile(\"47degrees\", \"github4s\", \"README.md\", \"A terser README.\", \"You read me right.\".getBytes,\"a52d080d2cf85e08bfcb441b437d3982398e8f8f6a58388f55d6b6cf51cb5365\") getContents.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"We could not update your file because ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) See the API doc for full reference. Delete a File This method deletes an existing file in a repository. You can create a new file using deleteFile, it takes as arguments: the repository coordinates (owner and name of the repository). path: The path of the new file to be created, without a leading slash. message: The message to use for creating the commit. sha: The blob SHA of the file being replaced. (This is returned as part of a getContents call). GitHub uses this value to perform optimistic locking. If the file has been updated since, the update call will fail. branch: The branch to add the commit to. If omitted, this defaults to the repository‚Äôs default branch. committer: An optional committer to associate with the commit. If omitted, the authenticated user‚Äôs information is used for the commit. author: An optional author to associate with the commit. If omitted, the committer is used (if present). To create a file: val getContents = gh.repos.deleteFile(\"47degrees\", \"github4s\", \"README.md\", \"Actually, we don't need a README.\", \"a52d080d2cf85e08bfcb441b437d3982398e8f8f6a58388f55d6b6cf51cb5365\") getContents.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"We could not delete this file because ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) See the API doc for full reference. Releases List of releases You can list releases using listReleases, it takes as arguments: the repository coordinates (owner and name of the repository). pagination Limit and Offset for pagination, optional. To list releases: val listReleases = gh.repos.listReleases( \"47deg\", \"github4s\", None, Map.empty) listReleases.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[Release]. Get a single release You can get a release using getRelease, it takes as arguments: the release coordinates (releaseId the id of the release) the repository coordinates (owner and name of the repository). Get a release by release id: val getRelease = gh.repos.getRelease( 123, \"47deg\", \"github4s\") getRelease.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding Option[Release]. The latest release You can get the latest release using latestRelease, it takes as arguments: the repository coordinates (owner and name of the repository). Get the latest release: val latestRelease = gh.repos.latestRelease( \"47deg\", \"github4s\") latestRelease.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding Option[Release]. Create a release Users with push access to the repository can create a release using createRelease; it takes as arguments: the repository coordinates (owner and name of the repository). tag_name: The name of the tag. name: The name of the release. body: Text describing the contents of the tag. target_commitish: Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository‚Äôs default branch (usually main). draft: true to create a draft (unpublished) release, false to create a published one. Default: false. prerelease: true to identify the release as a pre-release. false to identify the release as a full release. Default: false. To create a release: val createRelease = gh.repos.createRelease(\"47degrees\", \"github4s\", \"v0.1.0\", \"v0.1.0\", \"New access token\", Some(\"main\"), Some(false), Some(false)) createRelease.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the created Release. See the API doc for full reference. Statuses Create a status You can create a status using createStatus; it takes as arguments: the repository coordinates (owner and name of the repository). the SHA of the commit for which we want to create a status. the state of the status we want to create (can be pending, success, failure or error). other optional parameters: target url, description and context. To create a status: val createStatus = gh.repos.createStatus(\"47degrees\", \"github4s\", \"aaaaaa\", \"pending\", None, None, None) createStatus.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the created Status. See the API doc for full reference. List statuses for a specific ref You can also list statuses through listStatuses; it take as arguments: the repository coordinates (owner and name of the repository). a git ref (a SHA, a branch name or a tag name). pagination: Limit and Offset for pagination, optional. To list the statuses for a specific ref: val listStatuses = gh.repos.listStatuses(\"47degrees\", \"github4s\", \"heads/main\") listStatuses.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[Status]. See the API doc for full reference. Get the combined status for a specific ref Lastly, you can also get the combined status thanks to getCombinedStatus; it takes the same arguments as the operation listing statuses: val combinedStatus = gh.repos.getCombinedStatus(\"47degrees\", \"github4s\", \"heads/main\") combinedStatus.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding CombinedStatus. Note that the state of the combined status is the product of a heuristic detailed in the API documentation. As you can see, a few features of the repository endpoint are missing. As a result, if you‚Äôd like to see a feature supported, feel free to create an issue and/or a pull request!"
    } ,      
    {
      "title": "Team API",
      "url": "/github4s/team",
      "content": "Team API Github4s supports the Team API. As a result, with Github4s, you can interact with: Team List team The following examples assume the following code: import cats.effect.IO import github4s.Github import org.http4s.client.{Client, JavaNetClientBuilder} val httpClient: Client[IO] = JavaNetClientBuilder[IO].create // You can use any http4s backend val accessToken = sys.env.get(\"GITHUB_TOKEN\") val gh = Github[IO](httpClient, accessToken) Team List team You can list the teams for a particular organization with listTeams; it takes as arguments: org: name of the organization for which we want to retrieve the teams. pagination: Limit and Offset for pagination, optional. To list the teams for organization 47deg: val listTeams = gh.teams.listTeams(\"47deg\") listTeams.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[Team]. See the API doc for full reference."
    } ,    
    {
      "title": "User API",
      "url": "/github4s/user",
      "content": "User API Github4s supports the User API. As a result, with Github4s, you can interacts with: Users Get a user Get an authenticated user Get a list of users List users followed by another user import cats.effect.IO import github4s.Github import org.http4s.client.{Client, JavaNetClientBuilder} val httpClient: Client[IO] = JavaNetClientBuilder[IO].create // You can use any http4s backend val accessToken = sys.env.get(\"GITHUB_TOKEN\") val gh = Github[IO](httpClient, accessToken) Users Get a user Get information for a particular user. You can get a user using get, it takes as argument: username: of the user to retrieve. val getUser = gh.users.get(\"rafaparadela\") getUser.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding User. See the API doc for full reference. Get an authenticated user Get information of the authenticated user making the API call. You can get an authenticated user using getAuth: val getAuth = gh.users.getAuth() getAuth.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding User. See the API doc for full reference. Get a list of users You can get a list of users using getUsers, it takes as arguments: since: The integer ID of the last User that you‚Äôve seen. pagination: Limit and Offset for pagination. val getUsers = gh.users.getUsers(1) getUsers.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[User]. See the API doc for full reference. As you can see, a few features of the user endpoint are missing. As a result, if you‚Äôd like to see a feature supported, feel free to create an issue and/or a pull request! List users followed by another user You can get a list of users followed by another user using getFollowing, it takes as argument: username: of the user to retrieve. pagination: Limit and Offset for pagination, optional. val getFollowing = gh.users.getFollowing(\"rafaparadela\") getFollowing.flatMap(_.result match { case Left(e) =&gt; IO.println(s\"Something went wrong: ${e.getMessage}\") case Right(r) =&gt; IO.println(r) }) The result on the right is the corresponding List[User]. See the API doc for full reference."
    }    
  ];

  idx = lunr(function () {
    this.ref("title");
    this.field("content");

    docs.forEach(function (doc) {
      this.add(doc);
    }, this);
  });

  docs.forEach(function (doc) {
    docMap.set(doc.title, doc.url);
  });
}

// The onkeypress handler for search functionality
function searchOnKeyDown(e) {
  const keyCode = e.keyCode;
  const parent = e.target.parentElement;
  const isSearchBar = e.target.id === "search-bar";
  const isSearchResult = parent ? parent.id.startsWith("result-") : false;
  const isSearchBarOrResult = isSearchBar || isSearchResult;

  if (keyCode === 40 && isSearchBarOrResult) {
    // On 'down', try to navigate down the search results
    e.preventDefault();
    e.stopPropagation();
    selectDown(e);
  } else if (keyCode === 38 && isSearchBarOrResult) {
    // On 'up', try to navigate up the search results
    e.preventDefault();
    e.stopPropagation();
    selectUp(e);
  } else if (keyCode === 27 && isSearchBarOrResult) {
    // On 'ESC', close the search dropdown
    e.preventDefault();
    e.stopPropagation();
    closeDropdownSearch(e);
  }
}

// Search is only done on key-up so that the search terms are properly propagated
function searchOnKeyUp(e) {
  // Filter out up, down, esc keys
  const keyCode = e.keyCode;
  const cannotBe = [40, 38, 27];
  const isSearchBar = e.target.id === "search-bar";
  const keyIsNotWrong = !cannotBe.includes(keyCode);
  if (isSearchBar && keyIsNotWrong) {
    // Try to run a search
    runSearch(e);
  }
}

// Move the cursor up the search list
function selectUp(e) {
  if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index) && (index > 0)) {
      const nextIndexStr = "result-" + (index - 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Move the cursor down the search list
function selectDown(e) {
  if (e.target.id === "search-bar") {
    const firstResult = document.querySelector("li[id$='result-0']");
    if (firstResult) {
      firstResult.firstChild.focus();
    }
  } else if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index)) {
      const nextIndexStr = "result-" + (index + 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Search for whatever the user has typed so far
function runSearch(e) {
  if (e.target.value === "") {
    // On empty string, remove all search results
    // Otherwise this may show all results as everything is a "match"
    applySearchResults([]);
  } else {
    const tokens = e.target.value.split(" ");
    const moddedTokens = tokens.map(function (token) {
      // "*" + token + "*"
      return token;
    })
    const searchTerm = moddedTokens.join(" ");
    const searchResults = idx.search(searchTerm);
    const mapResults = searchResults.map(function (result) {
      const resultUrl = docMap.get(result.ref);
      return { name: result.ref, url: resultUrl };
    })

    applySearchResults(mapResults);
  }

}

// After a search, modify the search dropdown to contain the search results
function applySearchResults(results) {
  const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
  if (dropdown) {
    //Remove each child
    while (dropdown.firstChild) {
      dropdown.removeChild(dropdown.firstChild);
    }

    //Add each result as an element in the list
    results.forEach(function (result, i) {
      const elem = document.createElement("li");
      elem.setAttribute("class", "dropdown-item");
      elem.setAttribute("id", "result-" + i);

      const elemLink = document.createElement("a");
      elemLink.setAttribute("title", result.name);
      elemLink.setAttribute("href", result.url);
      elemLink.setAttribute("class", "dropdown-item-link");

      const elemLinkText = document.createElement("span");
      elemLinkText.setAttribute("class", "dropdown-item-link-text");
      elemLinkText.innerHTML = result.name;

      elemLink.appendChild(elemLinkText);
      elem.appendChild(elemLink);
      dropdown.appendChild(elem);
    });
  }
}

// Close the dropdown if the user clicks (only) outside of it
function closeDropdownSearch(e) {
  // Check if where we're clicking is the search dropdown
  if (e.target.id !== "search-bar") {
    const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
    if (dropdown) {
      dropdown.classList.remove("show");
      document.documentElement.removeEventListener("click", closeDropdownSearch);
    }
  }
}
